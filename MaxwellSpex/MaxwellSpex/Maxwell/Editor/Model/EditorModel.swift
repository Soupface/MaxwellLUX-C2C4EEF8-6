//
//  A New LUX
//  We dream with a world where human values are paramount for technological development, a future awoken by the renaissance of mankind awareness through a reconquered love for Art.
//  Creativity is a pathway born from the individual language of dreams to the unreachable destination of collective understanding. Through this paradoxical reflection, Art shines at the depth of stars as an eternally distant purpose.
//  Computers, software development and our digital reality had been driven by industrial and economic development. In just a lifetime, a tiny bit of humanity reached an unprecedented wealth sustained through technological advancements, but also rendering the abysmal inequality that reigns in present times.
//  For this reason, a world where technology serves humanity above all measure and profit, is the future where art blossoms. A future where creativity is unleashed, a step closer to our unreachable destination as the only known wardens of life and awareness.
//  Crafting intelligence shall be reconsidered as an artistic endeavor. The responsibility of crafting software and artificial intelligences that overpass the computational power of any average human is a god like power that corrupts when serving a selfish purpose...
//  For a future generation of code artists that wields this infinite power, a new breed of sensitive and prepared wizards that reclaim the true power of magic, for the ones that see beyond white light,  but every color from the electromagnetic spectrum, this artwork is crafted with much love for you and each of them.
//  “Thoroughly conscious ignorance is the prelude to every real advance in science.” ― James Clerk Maxwell
//  http://humanizedrobot.com
//
//  Licencing info 
//  FileHash: D7201C58-27FE-4334-B21E-8CE846444F88
//  {"id":"C14F470D","entitlements":{"email":"licenseduser@restored.maxwell.design","contract":"1. CONTRACT OF LICENSE\n    This document is a legal agreement between Maxwell Design ( Ben Sabbah Salazar alias Mark Maxwell ) and a Maxwell Design ( Ben Sabbah Salazar alias Mark Maxwell ) Authorized Reseller or Partner (a company or individual that has a commercial or a technical agreement with Maxwell Design ( Ben Sabbah Salazar alias Mark Maxwell ), (from now on “PARTNER” or “Licensed User”) eligible to purchase at the special Not For Resale condition and use the license of Maxwell Design ( Ben Sabbah Salazar alias Mark Maxwell ) SOFTWARE (from now on “SOFTWARE”) for testing purposes, demo to customers and internal usage. The use of the following SOFTWARE implies the PARTNER acceptance of these terms. The term \"SOFTWARE\" is used to identify the program received from Maxwell Design ( Ben Sabbah Salazar alias Mark Maxwell ) or downloaded from the official Maxwell Design ( Ben Sabbah Salazar alias Mark Maxwell ) app . Such term does not include any other program that is covered by a separate license and distributed as a different entity. By installing, copying, downloading, accessing to or in any way using the SOFTWARE, implies that Licensed User accepts to be bound by the terms of the present contract. If Licensed User do not accept the terms of the present contract, Maxwell Design ( Ben Sabbah Salazar alias Mark Maxwell ) does not grant the Licensed User the SOFTWARE in license. In this case, Licensed User are invited to abstain from installing, copying, downloading, accessing to or in any way using the SOFTWARE.\n\n     \n\n    2. PROPRIETARY RIGHTS\n    The SOFTWARE and any accompanying documentation are property of Maxwell Design ( Ben Sabbah Salazar alias Mark Maxwell ) and are protected by United States, Mexican and international laws. Licensed User further acknowledge and agree that Maxwell Design ( Ben Sabbah Salazar alias Mark Maxwell ) owns and shall continue to own all right, title, and interest in and to the SOFTWARE and Documentation, including associated intellectual property rights under copyright, trade secret, patent, or trademark laws. This Agreement does not grant Licensed User any ownership interest in or to the SOFTWARE or the Documentation, but only a limited right of use that is revocable in accordance with the terms of this Agreement.\n\n     \n\n    3. TERMS AND GUARANTEES\n    The SOFTWARE and accompanying documentation are being licensed to Licensed User, meaning that Licensed User have the right to use the SOFTWARE only in accordance to this License Agreement. The SOFTWARE is considered in use on a computer\/server\/electronic-device when it comes loaded on a temporary or permanent memory. The license is absolutely personal and strictly assegnide to the PARTNER, therefore it cannot be rented, sold or however sublicensed to other entities. The PARTNER can use the SOFTWARE for its company or for his personal use. Every licensed copy of the SOFTWARE can be installed on a single computer property of or in rent to the PARTNER. Once installed this copy cannot be installed on other computer unless the license is moved and it is not used any more on the original computer. The installed SOFTWARE can anyway be accessed from an unlimited number of computers through the browser or the telephone network. This license is valid from 2020-07-22 20:25:44 to 2119-07-22 20:25:44. It will be possible to cancel the license at any time by stopping to use all the copies of the SOFTWARE and the relative documentation without expecting anything from Maxwell Design ( Ben Sabbah Salazar alias Mark Maxwell ). THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n\n     \n\n    4. USES NOT ALLOWED\n    The SOFTWARE is permanently assigned to the PARTNER and the PARTNER can not resale, rent or transfer it in any way to any other entity (company or individual). The SOFTWARE can not be used in order to build and provide its functionalities as a Service (Hosted or SaaS) to End Users customers or to create a competing product or service.\n    Without the prior express written permission by Maxwell Design ( Ben Sabbah Salazar alias Mark Maxwell ) Licensed User may not a) Use, copy, or transfer, electronically or otherwise, the SOFTWARE or documentation except as expressly permitted in this License Agreement b) Decode, decompile or disassemble the SOFTWARE c) Modify the files which constitute the SOFTWARE d) Separate components. The SOFTWARE is granted in license as a single product. Single component parts cannot be separated for use on any other purpose.\n    YOU ARE PROHIBITED FROM SHARING, PUBLISHING OR OTHERWISE DISTRIBUTING COPIES OF THIS SOFTWARE IN ANY DIGITAL OR PRINT FORM. The  SOFTWARE is for your individual use or within your organization as allowed by your licensing agreement.\n    This means you CANNOT modify and upload a similar (or equal) version to the Apple AppStore, and CANNOT share the codebase in GitHub, BitBucket, DropBox, or any other public form of distribution.\n\n     \n\n    5. LIMITATION OF LIABILITY\n    In no event shall Maxwell Design ( Ben Sabbah Salazar alias Mark Maxwell ) liability related to any part of the Software exceed the license fees actually paid by you for the purchase of this license. Except for a return of the purchase price under the circumstances provided in the limited warranty, neither Maxwell Design ( Ben Sabbah Salazar alias Mark Maxwell ) nor its suppliers shall in any event be liable for any damages whatsoever arising out of or related to the use of or inability to use the SOFTWARE including but not limited to direct, indirect, special, incidental or consequential damages, and damages for loss of business profits, business interruption, loss of business information or other pecuniary loss, even if Maxwell Design ( Ben Sabbah Salazar alias Mark Maxwell ) has been advised of the possibility of such damages, whether such liability is based on contract, tort, warranty or any other legal or equitable grounds.\n\n     \n\n    6. COPYRIGHT\n    The ownership and the intellectual copyright concerning the SOFTWARE (therefore included, for example, every character, text, programming source code, image, logo, photography, animation, video, audio, music, text and \"graphics\" integrated into the SOFTWARE), the SOFTWARE enclosed, printed materials and any copy of the product are of Maxwell Design ( Ben Sabbah Salazar alias Mark Maxwell ) property. The ownership and the intellectual copyright concerning content that are not included in the SOFTWARE (but which the PARTNER can access by using the SOFTWARE) are of property of the respective owners and can be protected by laws and treated on the Copyright or other intellectual property. The use of any \"online\" service which the PARTNER can access by using the SOFTWARE will be disciplined by the relative conditions of use. If the SOFTWARE contains documentation provided exclusively in electronic form, the PARTNER is authorized to print one copy of the above-mentioned electronic documentation for his\/her use. The PARTNER cannot copy the printed materials enclosed into the SOFTWARE.\n\n     \n\n    7. GOVERNING LAW AND CHOICE OF FORUM\n    This Agreement shall be governed by and interpreted in accordance with the laws of United States, as if performed wholly within the state and without giving effect to the principles of conflicts of law. Any claim or dispute arising in connection with this Agreement shall be resolved in the courts situated in United States.","licensedProductId":"com.maxwelldesign.maxwell.v1.license.indie2","company":"Licensed User's Company","name":"Licensed User","mode":"normal"}}
//  http://maxwell.design
//
//
//  App+Model.swift
//  Styling
//
//  Created by Mark C. Maxwell on The New Lux
//  Copyright © 2020. All rights reserved.
//

import Combine
import Lux
import SwiftUI

protocol EditorReactiveAPI {
    var text: String { get set }
    var mode: EditorMode { get set }
    var galleryMode: EditorMode.Gallery { get set }
    var _editingMode: EditorMode.Editor { get set }

    var hideControls: Bool { get set }
    var sideMenu: Bool { get set }
    var preferences: [String: Any] { get set }

    var componentDetail: EditorModel.Detail? { get set }
    var isShowingSlider: Bool { get set }
    var isShowingColorPicker: Bool { get set }
    var isPickingFont: Bool { get set }

    var stateHash: String { get set }
    func setNeedsUpdate()
}

extension EditorModel {
    struct Detail {
        var section: EditorMode.Gallery
        var builder: EditorModel.SelectionBuilder
    }
}

class EditorModelStateObserver: EditorReactiveAPI, ObservableObject {
    @Published var text = "Maxwell"
    @Published var mode: EditorMode = .gallery
    @Published var galleryMode: EditorMode.Gallery = .card
    @Published var _editingMode: EditorMode.Editor = .undefinedFX

    @Published var hideControls = false
    @Published var sideMenu = false
    @Published var preferences: [String: Any] = [:]

    @Published var componentDetail: EditorModel.Detail?
    @Published var isShowingSlider = false
    @Published var isShowingColorPicker = false
    @Published var isPickingFont = false
    @Published var isConfiguringTexture = false
    @Published var isShowingColorWizard = false
    @Published var isDismissing = false
    @Published var isEditingMeta = false
    @Published var isSwapingPalette = false
    @Published var textInputBindingName: String? = nil
    @Published var textInputBuffer: String? = nil

    @Published var isUploading = false

    var textInputBinding: Binding<String>? {
        willSet {
            textInputBuffer = nil
        }
        didSet {
            objectWillChange.send()
        }
    }

    @Published var stateHash = UUID().uuidString
    @Published var session: EditorModel.Session
    @Published var importedLook: Look?

    func setNeedsUpdate() {
        stateHash = UUID().uuidString
    }

    init(session: EditorModel.Session) {
        self.session = session
    }
}

class EditorModel: ObservableObject {
    static let kuler = KulerModel()
    @Published var stateHash = UUID().uuidString
    let undoRedo = UndoRedo()
    let kuler = EditorModel.kuler
    let navigator = Navigator.shared

    let updateQueue = DispatchQueue(label: "updatequeue.\(UUID().uuidString)")
    static let saveQueue = DispatchQueue(label: "save.\(UUID().uuidString)")

    typealias SelectionBuilder = (Trait) -> AnyView
    typealias LookResult = (Look) -> Void

    static let refreshDelay = 0.25
    static let autoSaveDelay = 1.0

    var state: EditorModelStateObserver

    weak var colorPicker: DynamicColorPickerViewController?

    var onDismiss: LookResult?
    var onBookTap: (() -> Void)?
    var onStreamsTap: (() -> Void)?
    var onShareLookTap: ((Look) -> Void)?
    var onPersist: LookResult?
    var onAddLook: ((Look) -> Void)?
    var onKulerTap: ((Look) -> Void)?
    var onSourceCodeTap: ((EditorMode.Gallery) -> Void)?
    var onLoadCover: (() -> Void)?
    var lastLookHash: Int?

    var stateObserver: AnyCancellable?
    var lookObserver: AnyCancellable?
    var undoObserver: AnyCancellable?
    var autoSaveObserver: AnyCancellable?
    var colorPickerSelectObserver: AnyCancellable?

    var layoutIndex: Int = 0
    var surfaceIndex: Int = 0
    var colorIndex: Int = 0
    var labelIndex: Int = 0
    var fontIndex: Int = 0

    var preferredControlPreviewSurface: Look.Surface?
    var controlPreviewSurface: Look.Surface? {
        isColorPicker || isSlider ? preferredControlPreviewSurface : nil
    }

    init(session: Session) {
        EditorModel.storageDB.store(item: session)
        state = EditorModelStateObserver(session: session)
        setup()
    }

    init() {
        state = EditorModelStateObserver(session: Session())
        setup()
    }

    func setup() {
        setupObservers()
        setupKuler()
        saveInitialState()
    }

    func setupKuler() {
        kuler.onConfirm = { [weak self] colors in

            self?.state.isShowingColorWizard = false

            guard colors.isEmpty == false else { return }
            self?.importKuler(colors: colors)
        }

        kuler.onCancel = { [weak self] in

            self?.state.isShowingColorWizard = false
        }

        kuler.onExternalURL = { UIApplication.shared.open($0) }
        kuler.loadIfNeeded()
    }

    func importKuler(colors: [UIColor]) {
        let palette = Look.PaletteScheme.adaptKuler(colors: colors)
        look.color.apply(colors: palette)
    }

    func setupObservers() {
        stateObserver?.cancel()
        lookObserver?.cancel()
        undoObserver?.cancel()
        stateObserver = state.objectWillChange
            .throttle(for: .seconds(Self.refreshDelay), scheduler: RunLoop.main, latest: true)
            .sink { [weak self] _ in

                self?.syncCurrentLook()
                self?.setNeedsUpdate()
                self?.saveCurrentSession()
            }

        lookObserver = look.objectWillChange
            .throttle(for: .seconds(Self.refreshDelay), scheduler: RunLoop.main, latest: true)
            .sink { [weak self] _ in

                guard let this = self else { return }
                this.state.setNeedsUpdate()
            }

        undoObserver = look.objectWillChange
            .throttle(for: .seconds(1), scheduler: RunLoop.main, latest: true)
            .sink { [weak self] _ in

                guard let this = self else { return }

                this.registerUndo()
            }

        state.setNeedsUpdate()
    }

    func syncCurrentLook() {
        guard displayLook.hashValue != lastLookHash else { return }
        lastLookHash = displayLook.hashValue

        Look.set(active: displayLook)
    }

    func setNeedsUpdate() {
        stateHash = UUID().uuidString
    }
}

extension EditorModel {
    func setMode(_ mode: EditorMode) {
        DispatchQueue.main.async {
            self.mode = mode
        }
    }

    func setStylingMode(_ mode: EditorMode.Gallery) {
        DispatchQueue.main.async {
            self.showControls ? self.resetPresentingComponent() : nil
            self.galleryMode = mode
        }
    }

    func setEditingMode(_ mode: EditorMode.Editor, previewOnly _: Bool = false) {
        DispatchQueue.main.async {
            self.editingMode = mode
            self.isDark = self.look.scheme == .dark

            self.isShowingSlider = self.isSlider
            self.isShowingColorPicker = self.isColorPicker && !self.isShowingSlider
            self.isPickingFont = self.isFontPicker

            self.syncFontPicker()

            DispatchQueue.main.asyncAfter(deadline: .now() + 0.25) { [weak self] in
                guard self?.galleryMode != .spex else { return }
                self?.syncControlSubsurface()
            }
        }
    }
}

extension EditorModel {
    var isFontPicker: Bool {
        if case .font = editingMode {
            return true
        }

        return false
    }

    var isColorPicker: Bool {
        if case .color = editingMode {
            return true
        }

        if case .background = editingMode {
            return true
        }

        if case .label = editingMode {
            return true
        }

        if case .tintColor = editingMode {
            return true
        }

        if case .fillColor = editingMode {
            return true
        }

        if case .shadowColor = editingMode {
            return true
        }

        return false
    }

    var isSlider: Bool {
        switch editingMode {
        case .padding, .shadow, .roundness, .elevation, .tint, .fill:
            return true
        default:
            return false
        }
    }
}

extension EditorModel {
    var editingModeGroup: EditorMode.Editor.Group {
        get {
            switch editingMode {
            case .undefinedColor:
                return .color
            case .undefinedFX:
                return .fx
            case .undefinedFont:
                return .font
            default:
                break
            }

            switch editingMode {
            case .tintColor, .fillColor, .shadowColor:
                return .fx
            default:
                return isPaletteEffect ? .color : isFontEffect ? .font : .fx
            }
        }
        set {
            switch newValue {
            case .color:
                editingMode = defaultColorMode
            case .fx:
                editingMode = defaultEffectMode
            case .font:
                editingMode = defaultFontMode
            }
        }
    }

    var isPaletteEffect: Bool {
        switch editingMode {
        case .color, .background, .label:
            return true
        default:
            return false
        }
    }

    var isFontEffect: Bool {
        switch editingMode {
        case .font, .padding, .roundness:
            return true
        default:
            return false
        }
    }

    var isEffectValue: Bool {
        guard
            isPaletteEffect == false,
            isFontEffect == false
        else { return false }

        return true
    }
}

extension EditorModel {
    /// This is required due to some compiler error
    var editingMode: EditorMode.Editor {
        get {
            _editingMode
        }
        set {
            _editingMode = newValue
            syncPreferences()
        }
    }

    var showControls: Bool {
        get {
            !hideControls
        }
        set {
            hideControls = !newValue
        }
    }

    var isStyling: Bool {
        mode == .gallery
    }

    var isEditing: Bool {
        mode == .editor
    }

    var isDark: Bool {
        get {
            look.scheme == .dark
        } set {
            look.preferredScheme = newValue ? .dark : .light
        }
    }

    var isLight: Bool {
        !isDark
    }

    var title: String {
        galleryMode.rawValue.capitalized
    }

    var titleEditing: String {
        switch editingMode {
        case let .color(_, prio: prio):
            switch prio {
            case .primary:
                return "Active Surface 1"
            case .secondary:
                return "Active Surface 2"
            case .tertiary:
                return "Active Surface 3"
            default:
                return "Surface"
            }
        case let .background(_, prio: prio):
            switch prio {
            case .primary:
                return "Canvas Surface"
            case .secondary:
                return "Normal Surface"
            case .tertiary:
                return "Accent Surface"
            default:
                return "Surface"
            }
        case let .label(_, prio: prio):
            switch prio {
            case .primary:
                return "Light Contrast"
            case .secondary:
                return "Dark Contrast"
            case .tertiary:
                return "Label3"
            default:
                return "Color"
            }
        case .font:
            return "Font"
        case .padding:
            return "Padding"
        case .roundness:
            return "Roundness"
        case .shadow:
            return "Shadow"
        case .shadowColor:
            return "Shadow Color"
        case .elevation:
            return "Elevation"
        case .tint:
            return "Lighting"
        case .tintColor:
            return "Lighting Color"
        case .tintLayout:
            return "Lighting Layout"
        case .fill:
            return "Fill"
        case .fillColor:
            return "Fill Color"
        case .fillLayout:
            return "Fill Layout"
        case .undefinedColor, .undefinedFX, .undefinedFont:
            return ""
        }
    }
}

extension EditorModel {
    var defaultColorMode: EditorMode.Editor {
        .undefinedColor
    }

    var defaultEffectMode: EditorMode.Editor {
        .undefinedFX
    }

    var defaultFontMode: EditorMode.Editor {
        .undefinedFont
    }
}

extension EditorModel {
    var preferredColorMode: EditorMode.Editor {
        get {
            preferences["preferredColorMode"] as? EditorMode.Editor ?? .background(look.scheme, prio: .primary)
        }
        set {
            preferences["preferredColorMode"] = newValue
        }
    }

    var preferredEffectMode: EditorMode.Editor {
        get {
            preferences["preferredEffectMode"] as? EditorMode.Editor ?? .elevation
        }
        set {
            preferences["preferredEffectMode"] = newValue
        }
    }

    var preferredFontMode: EditorMode.Editor {
        get {
            preferences["preferredFontMode"] as? EditorMode.Editor ?? .font(prio: .primary)
        }
        set {
            preferences["preferredFontMode"] = newValue
        }
    }
}

extension EditorModel {
    func toggleEditingFX() {
        if mode == .editor, editingModeGroup == .fx {
            setGalleryMode()
            return
        }
        editingMode = preferredEffectMode
        mode = .editor
    }

    func toggleEditingFont() {
        if mode == .editor, editingModeGroup == .font {
            setGalleryMode()
            return
        }
        editingMode = preferredFontMode
        mode = .editor
    }

    func toggleEditingColor() {
        if mode == .editor, editingModeGroup == .color {
            setGalleryMode()
            return
        }
        editingMode = preferredColorMode
        mode = .editor
    }

    func setGalleryMode() {
        mode = .gallery
        dismissControls()
    }
}

extension EditorModel {
    func syncPreferences() {
        switch editingMode {
        case .undefinedColor:
            return preferredColorMode = _editingMode
        case .undefinedFX:
            return preferredEffectMode = _editingMode
        case .undefinedFont:
            return preferredFontMode = _editingMode
        default:
            break
        }
        isPaletteEffect ? preferredColorMode = _editingMode : nil
        isEffectValue ? preferredEffectMode = _editingMode : nil
        isFontEffect ? preferredFontMode = _editingMode : nil
    }
}

extension EditorModel {
    var isPresentingComponent: Bool {
        componentDetail != nil
    }

    func resetPresentingComponent() {
        componentDetail = nil
        setMode(.gallery)
        dismissLookOverrides()
    }

    func setcomponentDetail(section: EditorMode.Gallery, _ builder: @escaping SelectionBuilder) {
        componentDetail = EditorModel.Detail(section: section, builder: builder)
        setGalleryMode()
    }
}

extension EditorModel {
    var isShowingControlTool: Bool {
        isShowingColorPicker || isShowingSlider
    }

    func dismissSlider() {
        guard isShowingSlider else { return }
        preferredControlPreviewSurface = nil
//        isShowingSlider = false
        DispatchQueue.main.async {
            self.isShowingSlider = false
        }
    }

    func dismissColorPicker() {
        guard isShowingColorPicker else { return }
        preferredControlPreviewSurface = nil
        DispatchQueue.main.async {
            self.isShowingColorPicker = false
        }
    }

    func dismissControls() {
        dismissSlider()
        dismissColorPicker()
    }

    func dismissLookOverrides() {
        Look.current.resetDefaults()
    }
}

extension EditorModel: EditorReactiveAPI {
    var text: String {
        get {
            state.text
        } set {
            updateQueue.async {
                self.state.text = newValue
            }
        }
    }

    var mode: EditorMode { get {
        state.mode
    } set {
        updateQueue.async {
            self.state.mode = newValue
        }
    }
    }

    var galleryMode: EditorMode.Gallery { get {
        state.galleryMode
    } set {
        updateQueue.async {
            self.state.galleryMode = newValue
        }
    }
    }

    var _editingMode: EditorMode.Editor { get {
        state._editingMode
    } set {
        updateQueue.async {
            self.state._editingMode = newValue
        }
    }
    }

    var hideControls: Bool { get {
        state.hideControls
    } set {
        updateQueue.async {
            self.state.hideControls = newValue
        }
    }
    }

    var sideMenu: Bool { get {
        state.sideMenu
    } set {
        updateQueue.async {
            self.state.sideMenu = newValue
        }
    }
    }

    var preferences: [String: Any] { get {
        state.preferences
    } set {
        updateQueue.async {
            self.state.preferences = newValue
        }
    }
    }

    var componentDetail: EditorModel.Detail? { get {
        state.componentDetail
    } set {
        updateQueue.async {
            self.state.componentDetail = newValue
        }
    }
    }

    var isShowingSlider: Bool { get {
        state.isShowingSlider
    } set {
        updateQueue.async {
            self.state.isShowingSlider = newValue
        }
    }
    }

    var isShowingColorPicker: Bool { get {
        state.isShowingColorPicker
    } set {
        updateQueue.async {
            self.state.isShowingColorPicker = newValue
        }
    }
    }

    var isPickingFont: Bool { get {
        state.isPickingFont
    } set {
        updateQueue.async {
            self.state.isPickingFont = newValue
        }
    }
    }

    var isConfiguringTexture: Bool { get {
        state.isConfiguringTexture
    } set {
        updateQueue.async {
            self.state.isConfiguringTexture = newValue
        }
    }
    }
}

extension EditorModel {
    var displayLook: Look {
        look
    }

    var look: Look {
        get {
            state.session.tuningLook ?? state.session.look
        }
        set {
            state.session.look = newValue
        }
    }
}

extension EditorModel {
    func promoteImportedLux() {
        if let look = state.importedLook {
            state.session.look = look.clone()
        }
        clearImportedLux()
    }

    func saveImportedLux() {
        if let look = state.importedLook {
            onAddLook?(look.clone())
        }
    }

    func clearImportedLux() {
        DispatchQueue.main.async {
            self.state.importedLook = nil
        }
    }
}

extension EditorModel {
    var isTuning: Bool {
        state.session.tuningLook != nil
    }
}

/*

 var surfaceCanvas: Color {
     background
 }

 var normal: Color {
     background2
 }

 var surfaceAccent: Color {
     background3
 }

 var surfaceActive: Color {
     active
 }

 var surfaceContrast: Color {
     contrast
 }
 */
extension Look.PaletteScheme {
    var paletteKeypaths: [WritableKeyPath<Look.PaletteScheme, Color>] {
        [
            \Look.PaletteScheme.background, // surfaceCanvas
            \Look.PaletteScheme.background2, // normal
            \Look.PaletteScheme.background3, // surfaceAccent
            \Look.PaletteScheme.primary,
            \Look.PaletteScheme.secondary,
            \Look.PaletteScheme.tertiary,
        ]
    }

    mutating func apply(colors: [UIColor]) {
        assert(colors.count == paletteKeypaths.count)

        colors.enumerated().forEach { index, item in
            self[keyPath: paletteKeypaths[index]] = item.uiColor
        }
    }
}

extension Look.PaletteScheme {
    static func adaptKuler(colors: [UIColor]) -> [UIColor] {
        assert(colors.count == 5)
        let canvas = colors[0]
        let normal = colors[1]
        let primary = colors[2]
        let secondary = colors[3]
        let tertiary = colors[4]

        let foregroundColors = [secondary, tertiary]
        let avg = foregroundColors.reduce(HueColor(color: primary)) { result, color in
            let hueColor = HueColor(color: color)
            let h = result.hue + hueColor.hue / 2.0
            let s = result.saturation + hueColor.saturation / 2.0
            let b = result.brightness + hueColor.brightness / 2.0
            return HueColor(hue: h, saturation: 1.0 - s, brightness: 1.0 - b)
        }

        let accent = avg.toUIColor().contrast

        return [
            canvas,
            normal,
            accent,
            primary,
            secondary,
            tertiary,
        ]
    }
}

extension EditorModel {
    var hasChanges: Bool {
        state.session.look.asJSONString() != state.session.original.asJSONString()
    }

    func saveInitialState() {
        registerUndo()
        state.session.original = look.clone()
    }

    func dismiss() {
        hasChanges ?
            state.isDismissing = true
            : onDismiss?(look)
    }
}

extension EditorModel {
    func registerUndo() {
        let register = { [weak self] in
            guard let this = self else { return }
            this.undoRedo.registerUndoLookAction(editor: this)
        }

        register()
    }
}
